魔方自动求解程序一般有两种方法，一种是按照人还原魔方的步骤，一步步来，另外一种是使用数学方法，魔方自有一套复杂的数学理论，其中较著名的是两阶段算法（压缩文件中的cube430.exe使用的就是数学方法，程序作者便是two-phase算法发明人，文档中有该算的介绍）

本程序还原魔法使用的便是第一种方法。

程序界面仿wca的cube430.exe（文件夹中的wca-explorer.zip是完整程序）
程序还有bug，程序可能自动生成一个ml文件，保存bug发生时的魔方状态。但也可能是其他错误
如果你把自动生成的ml文件(在bug文件夹中)或者错误信息Email给我，我会非常感激。欢迎批评和建议。

这个程序还不完善，现阶段仅供学习之用，
1》尚未加入还原手法输出功能
2》尚未实现魔方状态有效性检测

实验方法：
1》依次点击界面中的按钮：
Cross：		在Front面实现Cross，然后把Cross转到底面（x'）
L1Corner：	还原底层角块
L2Edge：	还原第二层棱块
TopCross：	建立顶层十字
MatchCross：	对好十字
BackTopCorner	顶层四角块归位
RestoreTopCorener还原四角块
2》rotate组合框中是几个常用的魔方旋转操作，但是太少，可以使用Excute按钮前面的文本框输入旋转命令。命令名参考文件夹中的command-conventions.bmp中示意的命令名约定。
3》Reset按钮重置魔方
4》Empty便于抄写魔方。点击每个面这中间块，则选中该块颜色，点击非中间块，则该块颜色被改为当前选中颜色。由于尚未加入魔方有效性检测，如果改变颜色使魔方无效，则程序会出错。
5》save和open按钮用来保存和打开魔方状态文件（*.ml）
6》 random打乱魔方状态
7》solution按钮相当于连续执行了1》中提到的按钮对应的函数

本程序试图使用两套手法实现魔方还原，但现在实现了一种。两种手法的区别在于第三层的还原。前两层是一样的。
第一种手法的Cross的实现使用的是当前流行手法。
其余的步骤用到的手法主要参考了文件夹中的“魔方教程.pdf”，作者是厦门大学的何美生。程序中的函数与教程中的步骤是一一对应的。
本程序使用到的资料在information文件夹中

下面几个函数
	//2:cfop
	void HashOLL(char*);
	bool IsTopFaceRestored(void);
	void OLL(void);
	void HashPLL(char*);//not finished
	void PLL(void);
	void CFOP(void);
是第二套手法用到的函数，其中的最后一步
	void HashPLL(char*);//not finished
	void PLL(void);
两个函数尚未实现。

经验总结：
当要处理的状态是很多可能状态之一，而识别出当前的状态是哪种状态又比较困难时，可以考虑构造hash函数，以区别每一种状态。求出所有可能状态的hash值和当前状态hash值，识别当前状态是哪种状态时搜索hash值即可。本程序中第二种手法还原顶面时即用到该方法。使用状态hash的方法，可以屏蔽掉状态的复杂性。但是我想到这个方法时，前面的程序已经成型了，所以第一种方法实现时还是用了很多if-else或者switch，搞得头晕。
本程序在调试时也遇到了很大麻烦，不可能一开始就设断点调试的。后来采用的方法是每一个函数在出现问题时保存当前状态成文件，然后打开文件，继续执行时才在对应函数中设断点调试

欢迎此类经验的交流，如果你想到或用到了其他的方法，欢迎跟大家一起分享。


==========================================================================
updated content:
1>设置Excute按钮为default，避免了在输入命令后，按Enter键使程序退出的缺陷
2>增加了还原步骤的现实

note：
在还原过程中，本可以从计算机的角度进行搜索以减少步数，但我在程序中模拟人在还原方时的搜索匹配过程，便于实现，这导致还原的步骤较长。

2D版本中的资料并没有在2D-uptated版和3D版中出现。因为教程本身比较大，上传不便。如有需要，请下载最初的版本。
